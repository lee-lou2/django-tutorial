# 읽기/쓰기/업데이트 전용 필드 분리로 API 안정성 높이기

> API 보안과 데이터 무결성을 위해 Serializer의 필드를 용도별로 분리하여 안정적인 API 설계

## 필드 분리가 필요한 이유

- **보안 문제**: password 같은 민감한 필드가 GET 요청 시 노출될 위험
- **데이터 무결성**: id, created_at 등 시스템 자동 생성 값의 사용자 입력 방지
- **유효성 검사 복잡성**: 생성과 수정 시 다른 필드 요구사항 처리의 어려움
- **API 명세 모호함**: 클라이언트 개발자의 입력/응답 필드 구분 혼란

## 기본 전략: read_only와 write_only

```python
class UserSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True, required=True)
    
    class Meta:
        model = User
        fields = ['id', 'username', 'password', 'nickname', 'email', 'date_joined']
        read_only_fields = ['date_joined']
```

- **read_only=True**: 응답에만 포함, 입력 시 무시
- **write_only=True**: 입력에만 사용, 응답에 절대 포함하지 않음

## extra_kwargs를 활용한 필드 옵션 설정

Meta 클래스에서 여러 필드의 옵션을 한 번에 설정:

```python
class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'password', 'email', 'date_joined']
        extra_kwargs = {
            'password': {'write_only': True, 'style': {'input_type': 'password'}},
            'email': {'required': True},
            'date_joined': {'read_only': True},
        }
```

- **장점**: 별도 필드 선언 없이 Meta에서 일괄 설정
- **활용**: required, write_only, read_only, style 등 다양한 옵션 적용

## 심화 전략: 용도별 Serializer 분리

생성과 수정의 요구사항이 다를 경우 별도 Serializer 사용:

1. **UserCreateSerializer**: 회원 가입 전용
2. **UserUpdateSerializer**: 회원 정보 수정 전용  
3. **UserDetailSerializer**: 회원 정보 조회 전용

```python
# 생성 전용
class UserCreateSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['username', 'password', 'email', 'nickname']
        extra_kwargs = {
            'password': {'write_only': True},
            'email': {'required': True}
        }

# 수정 전용
class UserUpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['nickname', 'email']  # username 수정 불가

# 조회 전용
class UserDetailSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'nickname', 'email', 'date_joined']
```

## ViewSet에서 동적 Serializer 선택

```python
class UserViewSet(viewsets.ModelViewSet):
    queryset = User.objects.all()
    
    def get_serializer_class(self):
        if self.action == 'create':
            return UserCreateSerializer
        if self.action in ['update', 'partial_update']:
            return UserUpdateSerializer
        return UserDetailSerializer
```

## 실무 팁

- **상속을 통한 코드 중복 최소화**: 공통 필드를 가진 BaseSerializer 활용
- **API 문서화 연계**: get_serializer_class 사용으로 각 엔드포인트별 다른 스키마 자동 문서화
- **perform_create vs serializer.save()**: 추가 정보 주입 시에만 perform_create 오버라이드 사용
- **extra_kwargs 활용**: 간단한 필드 옵션은 별도 선언 대신 Meta에서 일괄 설정