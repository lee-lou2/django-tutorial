# Content Negotiation으로 JSON, XML, CSV 등 다양한 포맷 응답하기

> 하나의 URI에서 클라이언트 요구에 맞춰 JSON, XML, CSV 등 다양한 포맷으로 응답하는 콘텐츠 협상 기능 구현

## 콘텐츠 협상 개념

- 하나의 URI에서 동일한 리소스를 각기 다른 포맷으로 서비스하는 메커니즘
- HTTP Accept 헤더를 통해 클라이언트가 원하는 포맷을 서버에 전달
- 서버는 Content-Type 헤더로 응답 포맷을 명시

## DRF 렌더러 시스템

- Renderers: 서버 데이터를 특정 포맷의 바이트 스트림으로 변환하여 응답 생성
- 포맷 접미사(.json, .xml) 우선 확인 후 Accept 헤더 분석
- 지원 불가능한 포맷 요청 시 HTTP 406 Not Acceptable 응답

## 필요 라이브러리 설치

```bash
pip install djangorestframework-xml
pip install djangorestframework-csv
```

## 렌더러 설정

**전역 설정 (settings.py)**
```python
INSTALLED_APPS = [
    'rest_framework',
    'rest_framework_xml',
]

REST_FRAMEWORK = {
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework_xml.renderers.XMLRenderer',
        'rest_framework_csv.renderers.CSVRenderer',
    ],
}
```

**뷰별 설정**
```python
class BookViewSet(viewsets.ReadOnlyModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    renderer_classes = [JSONRenderer, XMLRenderer, CSVRenderer]
```

## API 테스트 방법

**Accept 헤더 사용**
- JSON: `Accept: application/json`
- XML: `Accept: application/xml`  
- CSV: `Accept: text/csv`

**포맷 접미사 사용**
- `http://127.0.0.1:8000/api/books.json`
- `http://127.0.0.1:8000/api/books.xml`
- `http://127.0.0.1:8000/api/books.csv`

## 실무 고려사항

- **데이터 구조 적합성**: CSV는 중첩된 데이터 표현에 제한적
- **성능**: JSON > XML > CSV 순으로 렌더링 속도 빠름
- **운영 환경**: BrowsableAPIRenderer는 개발 환경에서만 사용 권장
- **커스텀 렌더러**: BaseRenderer 상속으로 YAML, MessagePack 등 추가 포맷 지원 가능