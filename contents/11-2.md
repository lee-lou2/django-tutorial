# Gunicorn/Uvicorn과 Nginx를 활용한 실서버 배포 아키텍처

> Django 애플리케이션을 실제 서비스 환경에 배포하기 위한 표준 아키텍처로, Nginx가 클라이언트 요청을 받아 정적 파일은 직접 처리하고 동적 요청은 Gunicorn/Uvicorn으로 전달하는 구조

## 왜 이 조합을 사용하는가

**개발용 runserver의 한계**
- 단일 스레드로 동작하여 동시 접속 처리 불가
- 보안과 성능을 고려하지 않은 개발용 서버

**각 컴포넌트의 역할 분담**
- **Nginx (Web Server)**: 클라이언트 요청 수신, 정적 파일 서빙, 리버스 프록시, SSL/TLS 처리
- **Gunicorn (WSGI Server)**: Django 애플리케이션 실행 및 프로세스 관리
- **Uvicorn (ASGI Server)**: 비동기 처리 지원, Gunicorn과 결합하여 사용

## WSGI vs ASGI 선택 기준

- **비동기 기능 사용 시**: `async def` 뷰, Django Channels, StreamingHttpResponse 등이 있다면 ASGI 필수
- **현재 표준**: `Gunicorn + Uvicorn Worker` 조합이 현대적 선택

## 배포 설정 과정

**1. Gunicorn/Uvicorn 설치 및 실행**
```bash
pip install gunicorn uvicorn
gunicorn --bind unix:/run/gunicorn.sock --workers 3 -k uvicorn.workers.UvicornWorker myproject.asgi:application
```

**2. Systemd 서비스 등록**
- `/etc/systemd/system/gunicorn.service` 파일 생성
- 서버 재부팅 시 자동 실행 및 장애 시 재시작 보장

**3. Nginx 리버스 프록시 설정**
- `/etc/nginx/sites-available/myproject` 설정 파일 생성
- 정적 파일(`/static/`, `/media/`)은 Nginx가 직접 처리
- 동적 요청은 Gunicorn 소켓으로 전달

## 실무 운영 팁

**워커 개수 산정**
- 시작점: `(2 × CPU 코어 개수) + 1`
- 부하 테스트와 모니터링을 통해 최적값 도출

**무중단 배포**
- Gunicorn의 Graceful Restart 기능 활용
- `sudo systemctl reload gunicorn`으로 점진적 워커 교체

**보안 강화**
- Nginx에서 보안 헤더 설정
- Unix 소켓 사용으로 내부 통신 보안 향상

**정적 파일 처리**
- `collectstatic` 명령으로 정적 파일 수집
- Nginx가 직접 서빙하여 Django 서버 부하 감소