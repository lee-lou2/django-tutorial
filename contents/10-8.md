# Pytest와 유용한 플러그인으로 Django 테스트 환경 개선하기

> Django의 기본 unittest 대신 Pytest를 사용하여 더 간결하고 강력한 테스트 환경 구축. Fixture를 통한 재사용 가능한 테스트 설정과 다양한 플러그인으로 테스트 효율성 극대화

## Pytest 선택 이유

**코드 스타일**: 클래스 상속 없이 함수 스타일로 간결한 테스트 작성
**단언문**: 파이썬 기본 `assert` 문 사용으로 직관적이고 상세한 실패 메시지 제공
**테스트 셋업**: Fixture를 통한 재사용 가능하고 명시적인 의존성 주입
**플러그인 생태계**: 병렬 테스트, 커버리지 측정, 모킹 등 풍부한 기능 확장

## 기본 설정

**설치**: `pip install pytest pytest-django`

**pytest.ini 설정**:
```ini
[pytest]
DJANGO_SETTINGS_MODULE = config.settings.test
python_files = tests.py test_*.py *_test.py
addopts = -v -s --lf --nomigrations
```

**실행**: `pytest` 명령어로 모든 테스트 실행

## Fixture 활용

**기본 제공 Fixture**: `client`, `admin_client`, `rf`, `settings`, `django_user_model`

**커스텀 Fixture 생성**: `conftest.py`에서 프로젝트 전역 Fixture 정의
- 재사용성과 명시적 의존성으로 테스트 코드 개선
- `@pytest.fixture` 데코레이터로 생성
- 함수 인자로 필요한 Fixture 주입

## 필수 플러그인

**pytest-cov**: 테스트 커버리지 측정
- `pytest --cov=app_name --cov-report=html`로 HTML 리포트 생성

**pytest-xdist**: 테스트 병렬 실행
- `pytest -n auto`로 CPU 코어 수만큼 병렬 실행하여 시간 단축

**pytest-mock**: 외부 의존성 Mocking
- `mocker` Fixture로 외부 API, 파일 시스템 등을 가짜 객체로 대체

## 고급 기법

**Markers**: `@pytest.mark`로 테스트 그룹화 및 선택적 실행
- `pytest -m smoke`로 특정 마커 테스트만 실행

**Parametrization**: `@pytest.mark.parametrize`로 동일 로직을 다른 데이터로 반복 테스트
- 코드 중복 제거 및 테스트 의도 명확화