# 무한 스크롤을 위한 CursorPagination과 OffsetPagination의 차이

> API에서 대량의 데이터를 효율적으로 처리하기 위한 두 가지 페이지네이션 방식의 특징과 적용 상황을 비교

## 페이지네이션이 필요한 이유

- 성능 향상: 대량 데이터 처리 부담 감소로 응답 시간 단축
- 네트워크 부하 감소: 불필요한 데이터 전송 방지
- 사용자 경험 개선: 필요한 만큼의 데이터만 빠르게 로드

## OffsetPagination

**동작 원리**
- 데이터베이스의 OFFSET과 LIMIT 절 사용
- "100번째 아이템부터 10개를 보여줘" 방식으로 동작

**장점**
- 직관적인 구현
- 페이지 점프 가능

**단점**
- offset 값이 커질수록 쿼리 속도 급격히 저하
- 데이터 중복/누락 발생 가능 (실시간 데이터 변경 시)

## CursorPagination

**동작 원리**
- 커서(특정 아이템의 위치를 가리키는 고유한 값) 사용
- "이 아이템 다음부터 10개를 보여줘" 방식으로 동작
- 정렬 기준이 되는 컬럼 필수

**장점**
- 일정한 쿼리 성능 (페이지가 깊어져도 성능 저하 없음)
- 데이터 일관성 보장
- 실시간 데이터에 적합

**단점**
- 페이지 점프 불가 (이전/다음 페이지만 이동 가능)
- 복잡한 구현 (ordering 필드 신중한 설정 필요)
- 전체 개수 미제공

## 선택 가이드

| 구분 | OffsetPagination | CursorPagination |
|------|------------------|------------------|
| 성능 | 페이지가 깊어질수록 느려짐 | 일정함 |
| 데이터 일관성 | 중복/누락 발생 가능 | 보장됨 |
| 페이지 이동 | 특정 페이지 점프 가능 | 이전/다음만 가능 |
| 주요 사용처 | 검색 결과, 관리자 페이지 | 무한 스크롤, SNS 피드, 채팅 목록 |

**선택 기준**
- 실시간으로 데이터가 변하고 무한 스크롤 UI → CursorPagination
- 특정 페이지 점프 기능 필요 → OffsetPagination
- 대용량 데이터셋 (수만 건 이상) → CursorPagination 고려

## 실무 주의사항

- DB 인덱스 필수: ordering에 사용되는 필드에 반드시 인덱스 생성
- CursorPagination의 ordering 필드는 유니크한 값 보장하는 필드 조합으로 설정 (예: ['-created_at', '-id'])
- 프론트엔드와 명확한 소통: CursorPagination은 count 값 미제공