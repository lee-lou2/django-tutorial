# ListSerializer 커스텀으로 bulk_create/update 구현

> DRF의 ListSerializer를 커스터마이징하여 여러 객체를 한 번의 쿼리로 생성하거나 수정하는 방법. 기본 ListSerializer는 각 객체마다 개별 쿼리를 실행하여 N+1 문제를 발생시키지만, 커스텀 구현으로 성능을 획기적으로 개선 가능

## bulk_create 구현

**커스텀 ListSerializer 생성**
- `serializers.ListSerializer`를 상속받아 `create` 메서드 오버라이드
- `validated_data`를 모델 객체 리스트로 변환: `[Product(**item) for item in validated_data]`
- `Product.objects.bulk_create(products)`로 한 번에 생성
- `transaction.atomic()`으로 원자성 보장

**Serializer에 적용**
- `Meta` 클래스에 `list_serializer_class = CustomListSerializer` 설정
- View에서 `many=True` 옵션으로 사용

## bulk_update 구현

**커스텀 ListSerializer 생성**
- `update` 메서드 오버라이드하여 `instance`와 `validated_data` 처리
- `validated_data`를 id 기준으로 딕셔너리 매핑: `{item['id']: item for item in validated_data}`
- 각 객체의 필드를 `setattr(obj, field, value)`로 업데이트
- `Product.objects.bulk_update(objects_to_update, fields=['name', 'price'])`로 실행

**주의사항**
- update용 Serializer에서 `id` 필드를 `read_only_fields`에서 제외
- `fields` 매개변수에 업데이트할 필드 목록 명시 필요

## 실무 주의사항

**제약사항**
- `save()` 메서드가 호출되지 않아 오버라이드된 로직 미실행
- `pre_save`, `post_save` 시그널 미발생
- 시그널 의존 로직은 별도 서비스 함수로 분리하여 직접 호출

**데이터베이스 고려사항**
- 일부 구버전 DB에서 PK 반환 미지원 가능
- `ignore_conflicts=True` 옵션으로 UNIQUE 제약 조건 위반 처리 가능 (PostgreSQL만 지원)