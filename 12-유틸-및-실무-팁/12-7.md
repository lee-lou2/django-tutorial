# DRF와 GraphQL(Graphene) 함께 사용하기

> REST API의 안정성과 GraphQL의 유연성을 결합하여 다양한 클라이언트 요구사항에 효과적으로 대응하는 방법

## 함께 사용하는 이유

DRF와 GraphQL은 상호 보완적 관계로, 각각의 장점을 활용 가능

- **점진적 마이그레이션**: 기존 REST API 운영하며 새 기능부터 GraphQL로 구현
- **클라이언트별 최적화**: 모바일은 GraphQL로 데이터 효율성 확보, 데이터 분석은 REST API로 정형화된 데이터 제공
- **내부/외부 API 분리**: 내부 서비스 통신은 REST, 외부 공개 API는 GraphQL 사용

## 기본 설정

**패키지 설치**
```bash
pip install graphene-django django-graphql-jwt
```

**settings.py 설정**
```python
INSTALLED_APPS = [
    "graphene_django",
]

GRAPHENE = {
    "SCHEMA": "myproject.schema.schema",
    "MIDDLEWARE": [
        "graphql_jwt.middleware.JSONWebTokenMiddleware",
    ],
}
```

**URL 설정**
```python
path("graphql", csrf_exempt(GraphQLView.as_view(graphiql=True))),
```

## 스키마 작성

**모델을 GraphQL 타입으로 변환**
```python
class UserType(DjangoObjectType):
    class Meta:
        model = CustomUser
        fields = ("id", "username", "email", "last_login")
```

**현재 사용자 정보 조회**
```python
def resolve_me(self, info):
    user = info.context.user
    if not user.is_authenticated:
        raise Exception("Authentication credentials were not provided")
    return user
```

## 실무 활용 팁

**DRF Serializer 재활용**
- 기존 유효성 검사 로직을 GraphQL Mutation에서 재사용
- 코드 중복 방지 및 비즈니스 로직 통합 관리

**N+1 문제 해결**
- `graphene-django-optimizer` 사용으로 자동 최적화
- `select_related`와 `prefetch_related` 자동 적용

**권한 관리**
- DRF 권한 클래스를 GraphQL Resolver에서 직접 호출
- 일관된 권한 정책 유지

## 주의사항

- **단일 진실 공급원**: 비즈니스 로직은 한 곳에서만 관리
- **복잡한 쿼리 제한**: 쿼리 깊이나 복잡도 제한 필요
- **캐싱 전략**: GraphQL의 복잡한 캐싱 고려사항 대응