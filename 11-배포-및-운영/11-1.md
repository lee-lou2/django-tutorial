# Docker와 Docker Compose로 일관성 있는 환경 구축하기

> 개발, 테스트, 운영 환경에서 동일하게 동작하는 Django 애플리케이션 환경을 Docker 컨테이너로 구축하여 "내 컴퓨터에서는 잘 됐는데..." 문제를 해결하고 팀원 간 환경 불일치를 방지

## Docker 사용 이유

**환경 불일치 문제 해결**
- 팀원 간의 Python 버전, OS별 라이브러리 차이 해결
- 복잡한 개발 환경 설정 과정 단순화
- 개발 환경과 운영 환경 차이로 인한 배포 후 에러 방지

**Docker 핵심 개념**
- 컨테이너: 애플리케이션과 실행 환경을 격리된 공간에 패키징
- 이미지: 컨테이너 실행을 위한 패키지
- Docker Compose: 여러 컨테이너를 하나의 파일로 정의하고 관리

## Dockerfile 작성

**기본 구조**
```dockerfile
FROM python:3.11-slim
ENV PYTHONDONTWRITEBYTECODE 1
ENV PYTHONUNBUFFERED 1
WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .

EXPOSE 8000
CMD ["gunicorn", "config.wsgi:application", "--bind", "0.0.0.0:8000"]
```

**최적화 팁**
- slim 버전 사용으로 이미지 크기 감소
- requirements.txt 먼저 복사 후 코드 복사로 빌드 캐시 활용
- .dockerignore 파일로 불필요한 파일 제외

## Docker Compose 환경 구축

**개발 환경 구성**
```yaml
version: '3.8'

services:
  db:
    image: postgres:15-alpine
    volumes:
      - postgres_data:/var/lib/postgresql/data/
    environment:
      - POSTGRES_USER=${DB_USER}
      - POSTGRES_PASSWORD=${DB_PASSWORD}
      - POSTGRES_DB=${DB_NAME}

  app:
    build: .
    volumes:
      - .:/app
    ports:
      - "8000:8000"
    command: python manage.py runserver 0.0.0.0:8000
    depends_on:
      - db

volumes:
  postgres_data:
```

**환경변수 관리**
- .env 파일로 민감 정보 분리
- 운영 환경에서는 AWS Secrets Manager 등 전문 도구 사용 권장

## 운영 환경 아키텍처

**Nginx + Gunicorn 구성**
- Gunicorn: Python WSGI 서버로 Django 요청 병렬 처리
- Nginx: 리버스 프록시로 정적 파일 처리, 로드 밸런싱, SSL 암호화

**운영 환경 특징**
- 코드 볼륨 마운트 제거
- 정적/미디어 파일 볼륨 분리
- Health Check를 통한 서비스 상태 모니터링
- Graceful Shutdown 처리로 안전한 서비스 종료

## 실무 핵심 팁

**보안 및 안정성**
- 민감 정보는 전용 서비스에서 관리
- Multi-Stage Build로 운영용 이미지 최적화
- DB 연결 대기 로직 추가로 안정적인 서비스 시작

**성능 최적화**
- Docker 레이어 캐시 활용으로 빌드 속도 향상
- 불필요한 파일 제외로 이미지 크기 감소
- Health Check로 실제 서비스 가용성 확인